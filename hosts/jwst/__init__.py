################################################################################
# oops/hosts/jwst/__init__.py
################################################################################

import astropy.io.fits as pyfits
import os

import julian
import oops
import hosts.solar as solar

from polymath import Vector3

# A handy constant
RADIANS_PER_ARCSEC = oops.RPD / 3600.

INSTRUMENT_NAME = {
    'MIRI'   : 'MIRI',
    'NIRCAM' : 'NIRCam',
    'NIRISS' : 'NIRISS',
    'NIRSPEC': 'NIRSpec',
}

# Define some important paths and frames
oops.Body.define_solar_system('2022-01-01', '2030-01-01')

################################################################################
# Standard instrument methods
################################################################################

def from_file(filespec, **options):
    """An Observation object based on a given data file generated by the James
    Webb Space Telescope.

    Inputs:
        filespec        path to the FITS file.

    Options:
        data            True (the default) to include the data arrays in the
                        returned Observation.

        calibration     True (the default) to include calibration subfields
                        in the Observation.

        astrometry      If True, this is equivalent to data=False,
                        calibration=False.

        reference       An optional second JWST Observation. If specified, then
                        this Observation will use a frame defined as an offset
                        from that of the reference.

        target          If specified, the name of the target body. Otherwise,
                        the target body is inferred from the header.

    Instrument-specific methods may support additional options.
    """

    # Open the file
    hdulist = pyfits.open(filespec)

    try:
        # Confirm that the telescope is JWST
        if JWST().telescope_name(hdulist) != 'JWST':
            raise IOError('not a JWST file: ' + filespec)

        return JWST.from_hdulist(hdulist, **options)

    finally:
        hdulist.close()

################################################################################
# Class JWST
################################################################################

class JWST(object):
    """This class defines functions and properties unique to the James Webb
    Space Telescope.

    Objects of this class are empty; they only exist to support inheritance.
    """

    ############################################
    # General file info
    ############################################

    def filespec(self, hdulist, **options):
        """The full directory path and name of the file."""

        # Found by poking around inside a pyfits object
        return hdulist._file.name

    def basename(self, hdulist, **options):
        """The base name of the file."""

        return os.path.basename(hdulist._file.name)

    def telescope_name(self, hdulist, **options):
        """Telescope name, should be "JWST"."""

        return hdulist[0].header['TELESCOP']

    def instrument_name(self, hdulist, **options):
        """Instrument name, one of "NIRCam", "NIRSpec", "MIRI", or "NIRISS"."""

        capname = hdulist[0].header['INSTRUME']
        return INSTRUMENT_NAME[capname]

    def header_subfields(self, hdulist, **options):
        """Default subfields for all JWST Observations."""

        header0 = hdulist[0].header
        header1 = hdulist[1].header

        subfields = {}
        subfields['telescope' ] = 'JWST'
        subfields['instrument'] = INSTRUMENT_NAME[header0['INSTRUME']]
        subfields['detector'  ] = header0['DETECTOR']
        subfields['filter'    ] = header0['FILTER']
        subfields['target'    ] = self.target_name(hdulist, **options)
        subfields['headers'   ] = [header0, header1]

        if 'data' in options:
            include_data = options['data']
        else:
            include_data = not options.get('astrometry', False)

        if include_data:
            subfields['data'] = hdulist['SCI'].data
            if 'ERROR' in hdulist:
                subfields['error'] = hdulist['ERROR'].data
            if 'DQ' in hdulist:
                subfields['quality'] = hdulist['DQ'].data

        return subfields

    def check_options(self, options):
        """Fill in option defaults."""

        astrometry_mode = options.get('astrometry', False)
        options['data'] = options.get('data', not astrometry_mode)
        options['calibration'] = options.get('calibration', not astrometry_mode)

        options['reference'   ] = options.get('reference'   , None)
        options['target'      ] = options.get('target'      , None)
        options['frame_suffix'] = options.get('frame_suffix', '')
        options['path_suffix' ] = options.get('path_suffix' , '')

        return options

    ############################################
    # Cadence support
    ############################################

    def time_limits(self, hdulist, **options):
        """A tuple containing the overall start and end times of the observation
        as seconds TDB."""

        header0 = hdulist[0].header
        start_tai = julian.tai_from_iso(header0['DATE-BEG'])
        stop_tai  = julian.tai_from_iso(header0['DATE-END'])
        start_tdb = julian.tdb_from_tai(start_tai)
        stop_tdb  = julian.tdb_from_tai(stop_tai)

        return (start_tdb, stop_tdb)

    def row_cadence(self, hdulist, **options):
        """Default cadence for JWST, with one time step per image row."""

        tstride = hdulist[0].header['TFRAME']       # seconds between frames
        nrows   = hdulist[1].header['NAXIS2']

        (start_tdb, stop_tdb) = self.time_limits(hdulist, **options)
        return oops.cadence.Metronome(tstart = start_tdb,
                                      tstride = tstride/nrows,
                                      texp = stop_tdb - start_tdb - tstride,
                                      steps = nrows)

    ############################################
    # Path support
    ############################################

    def jwst_path(self, hdulist, **options):
        """A LinearPath using the geometry info in the FITS header."""

        h1 = hdulist[1].header

        eph_time = h1['EPH_TIME']   # MJD time of position and velocity vectors
        jwst_x   = h1['JWST_X  ']   # [km] barycentric JWST X coordinate
        jwst_y   = h1['JWST_Y  ']   # [km] barycentric JWST Y coordinate
        jwst_z   = h1['JWST_Z  ']   # [km] barycentric JWST Z coordinate
        jwst_dx  = h1['JWST_DX ']   # [km/s] barycentric JWST X velocity
        jwst_dy  = h1['JWST_DY ']   # [km/s] barycentric JWST Y velocity
        jwst_dz  = h1['JWST_DZ ']   # [km/s] barycentric JWST Z velocity

        epoch = julian.tdb_from_tai(julian.tai_from_mjd(eph_time))
        pos = Vector3((jwst_x , jwst_y , jwst_z ))
        vel = Vector3((jwst_dx, jwst_dy, jwst_dz))
        path_id = self.basename(hdulist, **options) + options['path_suffix']

        return oops.path.LinearPath(pos = (pos, vel),
                                    epoch = epoch,
                                    origin = oops.Path.SSB,
                                    frame = oops.Frame.J2000,
                                    path_id = path_id)

    ############################################
    # Frame support
    ############################################

    def target_name(self, hdulist, **options):
        """Name of the image target."""

        if 'target' in options:
            return options['target']

        return hdulist[0].header['TARGNAME']

    def target_body(self, hdulist, **options):
        """The body object defining the image target."""

        return oops.Body.lookup(self.target_name(hdulist, **options))

    def tracker_frame(self, hdulist, fov, path, **options):
        """A TrackerFrame for the observation.

        This frame ensures that the target object stays at the same location on
        the detector for the duration of the observation.
        """

        # fov.cmatrix rotates _apparent_ J2000 coordinates to the camera frame.

        # Remove the aberration present in the FOV's C matrix
        header1 = hdulist[1].header
        ephem_mjd = header1['EPH_TIME']
        epoch = julian.tdb_from_tai(julian.tai_from_mjd(ephem_mjd))

        # Insert apparent vector as actual to reverse the aberration effect
        event = oops.Path.as_path(path).event_at_time(epoch).wrt_ssb()
        event.neg_arr_j2000 = oops.Vector3.from_ra_dec_length(fov.ra, fov.dec,
                                                              recursive=False)
        (ra, dec) = event.ra_and_dec(apparent=True)

        # This frame describes the actual fixed pointing at epoch
        cmatrix = oops.frame.Cmatrix.from_ra_dec(ra, dec, fov.clock)

        # This frame applies for the duration of the observation
        target_body = self.target_body(hdulist, **options)
        frame_id = self.basename(hdulist, **options) + options['frame_suffix']

        return oops.frame.TrackerFrame(frame = cmatrix,
                                       target = target_body.path,
                                       observer = path,
                                       epoch = epoch,
                                       frame_id = frame_id)

    def offset_frame(self, hdulist, reference, **options):
        """A PosTargFrame for the observation, based on a fixed offset from the
        frame of another observation.
        """

        xpos = hdulist[0].header['XOFFSET'] - reference.headers[0]['XOFFSET']
        ypos = hdulist[0].header['YOFFSET'] - reference.headers[0]['YOFFSET']
        xpos *=  RADIANS_PER_ARCSEC
        ypos *= -RADIANS_PER_ARCSEC
        frame_id = self.basename(hdulist, **options) + options['frame_suffix']

        return oops.frame.PosTargFrame(xpos = xpos,
                                       ypos = ypos,
                                       reference = reference.frame,
                                       frame_id = frame_id)

    def instrument_frame(self, hdulist, fov, path, **options):
        """Either a TrackerFrame or a PosTargFrame, depending on the presence of
        a "reference" option.
        """

        if options['reference']:
            return self.offset_frame(hdulist = hdulist,
                                     reference = options['reference'],
                                     **options)
        else:
            return self.tracker_frame(hdulist = hdulist,
                                      fov = fov,
                                      path = path,
                                      **options)

    ############################################
    # Calibration support
    ############################################

    def iof_factor(self, hdulist, path, **options):
        """The factor(s) for converting DN per second to I/F."""

        # Get the calibration factors from the header
        try:
            photuja2 = hdulist[1].header['PHOTUJA2']    # uJy/arcsec2 for 1 cps
            pixar_a2 = hdulist[1].header['PIXAR_A2']    # pixel area in arcsec^2
        except KeyError:
            raise IOError('Calibration factors missing from FITS file '
                          + self.filespec)

        # Observation event
        times = self.time_limits(hdulist, **options)
        tdb = (times[0] + times[1]) / 2.
        obs_event = oops.Event(tdb, Vector3.ZERO, path, path.frame)

        # Target position as observed
        target_path = self.target_body(hdulist, **options).path.wrt_ssb()
        (target_event, _) = target_path.photon_to_event(obs_event)

        # Sun position as photon source
        sun_path = oops.Body.lookup('SUN').path.wrt_ssb()
        (sun_event, _) = sun_path.photon_to_event(target_event)

        solar_range = (target_event.pos - sun_event.pos).norm().vals / solar.AU

        # Get solar F averaged over the filter bandpass
        bandpass = self.filter_bandpass(hdulist, **options)
        solar_model = options.get('solar_model', 'STIS_Rieke')
        solar_f_in_uJy = solar.bandpass_f(bandpass, model=solar_model,
                                          units='uJy', xunits='um',
                                          sun_range=solar_range)

        return photuja2 * pixar_a2 / solar_f_in_uJy

    ############################################################################

    @staticmethod
    def from_hdulist(hdulist, **options):
        """An Observation object based on the HDUlist from a JWST FITS data
        file, plus additional options.
        """

        # Make an instance of the JWST class
        jwst = JWST()

        # Confirm that the telescope is JWST
        if jwst.telescope_name(hdulist) != 'JWST':
            raise IOError('not an JWST file: ' + jwst.filespec(hdulist))

        # Select the instrument
        instrument = jwst.instrument_name(hdulist)
        if instrument == 'NIRCam':
            from hosts.jwst.nircam import NIRCam
            obs = NIRCam.from_hdulist(hdulist, **options)

# TODO
#         elif instrument == 'NIRSPEC':
#             from oops.hosts.jwst.nirspec import NIRSPEC
#             obs = NIRSpec.from_hdulist(hdulist, **options)
#
#         elif instrument == 'MIRI':
#             from oops.hosts.jwst.miri import MIRI
#             obs = MIRI.from_hdulist(hdulist, **options)
#
#         elif instrument == 'NIRISS':
#             from oops.hosts.jwst.niriss import NIRISS
#             obs = NIRISS.from_hdulist(hdulist, **options)

        else:
            raise IOError('unsupported instrument %s in JWST file: %s'
                          % (instrument, jwst.filespec(hdulist)))

        return obs

################################################################################
# UNIT TESTS
################################################################################

import unittest

class Test_JWST(unittest.TestCase):

    def runTest(self):
        pass

########################################
if __name__ == '__main__': # pragma: no cover
    unittest.main(verbosity=2)
################################################################################
